<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metrics.Legacy</name>
    </assembly>
    <members>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.Count``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns the number of elements in a sequence.
            </summary>
            <typeparam name="TSource">he type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasExactly``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasMoreThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains more than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasFewerThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less then <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.Any``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Determines whether a sequence contains any elements.
            </summary>
            <typeparam name="T">The type of the elements of array.</typeparam>
            <typeparam name="TArg">The type of arg.</typeparam>
            <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <param name="arg">The argument to pass into the predicate.</param>
            <returns> true if any elements in the source sequence pass the test in the specified predicate otherwise, false.</returns>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="obj">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="obj">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a <paramref name="value"/> to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the given <paramref name="values"/> to the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="item">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Clear">
            <summary>
            Clears all the elements from the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Contains(`0)">
            <summary>
            Returns true if the given <paramref name="item"/> is present in the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>.
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Free(`0,System.Threading.CancellationToken)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1">
            <summary>
            Pooled <see cref="T:System.Collections.Generic.SortedSet`1"/>.
            </summary>
            <typeparam name="T">Type of elements in the set.</typeparam>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledSortedSet`1.GetInstance(System.Collections.Generic.IComparer{`0})">
            <summary>
            Gets a pooled instance of a <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/> with an optional comparer.
            </summary>
            <param name="comparer">Singleton (or at least a bounded number) comparer to use, or null for the element type's default comparer.</param>
            <returns>An empty <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledSortedSet`1.GetInstance(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Gets a pooled instance of a <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/> with the given initializer and an optional comparer.
            </summary>
            <param name="initializer">Initializer for the set.</param>
            <param name="comparer">Comparer to use, or null for the element type's default comparer.</param>
            <returns>An empty <see cref="T:Analyzer.Utilities.PooledObjects.PooledSortedSet`1"/>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.AdditionalFileProvider">
            <summary>
            Provider that allows analyzers to easily find and use
            <see href="https://github.com/dotnet/roslyn/blob/main/docs/analyzers/Using%20Additional%20Files.md">additional files</see>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.FromOptions(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions)">
            <summary>
            Creates an instance of this provider from the specified <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions"/>.
            </summary>
            <param name="options">Options passed to a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.</param>
            <returns>An instance of <see cref="T:Analyzer.Utilities.AdditionalFileProvider"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.GetFile(System.String)">
            <summary>
            Returns the first additional file whose name is the specified <paramref name="fileName"/>.
            </summary>
            <param name="fileName">Name of the file, including extension, to return.</param>
            <returns>An additional file or <c>null</c> if no file can be found.</returns>
        </member>
        <member name="M:Analyzer.Utilities.AdditionalFileProvider.GetMatchingFiles(System.String)">
            <summary>
            Returns all additional files whose names match the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">A regular expression.</param>
            <returns>An enumeration of additional files whose names match the pattern.</returns>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCacheWithFactory`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.DoNotCatchGeneralUnlessRethrownAnalyzer.DisallowGeneralCatchUnlessRethrowWalker">
            <summary>
            Walks an IOperation tree to find catch blocks that handle general types without rethrowing them.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.CompilationExtensions">
            <summary>
            Provides extensions to <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.IsWebProject(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions)">
            <summary>
            Gets a value indicating whether the project of the compilation is a Web SDK project based on project properties.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.GetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TryGetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TargetsDotNetFramework(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets a value indicating, whether the compilation of assembly targets .NET Framework.
            This method differentiates between .NET Framework and other frameworks (.NET Core, .NET Standard, .NET 5 in future).
            </summary>
            <param name="compilation">The compilation</param>
            <returns><c>True</c> if the compilation targets .NET Framework; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IPropertySymbolExtensions.IsAutoProperty(Microsoft.CodeAnalysis.IPropertySymbol)">
            <summary>
            Check if a property is an auto-property.
            TODO: Remove this helper when https://github.com/dotnet/roslyn/issues/46682 is handled.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.SourceTextExtensions">
            <summary>
            Class that contains extensions to <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.SourceTextExtensions.Parse``1(Microsoft.CodeAnalysis.Text.SourceText,System.Func{System.IO.StreamReader,``0})">
            <summary>
            Reads the <paramref name="text"/> contents into a stream and returns the result of calling the
            <paramref name="parser"/> function on that stream.
            </summary>
            <typeparam name="T">Type to deserialize from the <paramref name="text"/>.</typeparam>
            <param name="text">Abstraction for an additional file's contents.</param>
            <param name="parser">Function that will parse <paramref name="text"/> into <typeparamref name="T"/>.</param>
            <returns>Output from <paramref name="parser"/>.</returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.DiagnosticExtensions.s_syntaxTreeDiagnosticOptionsProperty">
            <summary>
            TODO: Revert this reflection based workaround once we move to Microsoft.CodeAnalysis version 3.0
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasExactly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasMoreThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains more than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasFewerThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.WhereMethodDoesNotContainAttribute(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Excludes <paramref name="methods"/> that have an attribute that precisely matches <paramref name="attributeType"/>.
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to filter.</param>
            <param name="attributeType">The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> of the attribute class to search.</param>
            <returns>A filtered list of methods.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its first parameter or the last parameter in addition to matching all the other 
            parameter types of the selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
            <param name="trailingOnly"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> If the expected parameter should appear at the trailing position of the parameter list of the method overload</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its last parameter in addition to matching all the other parameter types of the 
            selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedTrailingParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterTypes(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> in the sequence who's parameters match <paramref name="expectedParameterTypesInOrder"/>.
            </summary>
            <param name="members">The sequence of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s to search.</param>
            <param name="expectedParameterTypesInOrder">The types of the parameters, in order.</param>
            <returns>
            The first <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> in the sequence who's parameters match <paramref name="expectedParameterTypesInOrder"/>, or <langword>null</langword> if
            no method was found.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterInfos(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Analyzer.Utilities.Extensions.ParameterInfo[])">
            <summary>
            Given a <see cref="T:System.Collections.Generic.IEnumerable`1"/>, this method returns the method symbol which 
            matches the expectedParameterTypesInOrder parameter requirement
            </summary>
            <param name="members"></param>
            <param name="expectedParameterTypesInOrder"></param>
            <returns></returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterTypes(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ITypeSymbol})">
            <summary>
            Given an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, returns the <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> whose parameter list
            matches <paramref name="expectedParameterTypesInOrder"/>.
            </summary>
            <param name="members"></param>
            <param name="expectedParameterTypesInOrder">Expected types of the member's parameters.</param>
            <returns>
            The first member in the sequence whose parameters match <paramref name="expectedParameterTypesInOrder"/>, 
            or null if no matches are found.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEqualsOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsStaticObjectEqualsOrReferenceEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given <paramref name="method"/> is <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsGetHashCodeOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.GetHashCode.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsToStringOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.ToString.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectMethodOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides a method from System.Object
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsFinalizer(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is a Finalizer implementation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsImplementationOfInterfaceMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Checks if the given method is an implementation of the given interface method
            Substituted with the given typeargument.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Checks if the given method implements IDisposable.Dispose()
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAsyncDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Checks if the given method implements IAsyncDisposable.Dispose()
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements <see cref="M:System.IDisposable.Dispose"/> or overrides an implementation of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAsyncDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements "IAsyncDisposable.Dispose" or overrides an implementation of "IAsyncDisposable.Dispose".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeSignatureByConvention(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method matches Dispose method convention and can be recognized by "using".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeBoolMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Close()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task CloseAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task DisposeAsync()" or "ValueTask DisposeAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasOverriddenDisposeCoreAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "override Task DisposeCoreAsync(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOnDeserializationImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization' or overrides an implementation of 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization'/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is a property getter.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsIndexerGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is the getter for an indexer.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for a property.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsEventAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for an event.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants">
            <summary>
            Set of well-known collection add method names.
            Used in <see cref="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})"/> heuristic.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Determine if the specific method is an Add method that adds to a collection.
            </summary>
            <param name="method">The method to test.</param>
            <param name="iCollectionTypes">Collection types.</param>
            <returns>'true' if <paramref name="method"/> is believed to be the add method of a collection.</returns>
            <remarks>
            We use the following heuristic to determine if a method is a collection add method:
            1. Method's enclosing type implements any of the given <paramref name="iCollectionTypes"/>.
            2. Any of the following name heuristics are met:
                a. Method's name is from one of the well-known add method names from <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants"/> ("Add", "AddOrUpdate", "GetOrAdd", "TryAdd", or "TryUpdate")
                b. Method's name begins with "Add" (FxCop compat)
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskFromResultMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.FromResult method that wraps a result in a task.
            </summary>
            <param name="method">The method to test.</param>
            <param name="taskType">Task type.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskConfigureAwaitMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.ConfigureAwait(bool) method.
            </summary>
            <param name="method">The method to test.</param>
            <param name="genericTaskType">Generic task type.</param>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache">
            <summary>
            PERF: Cache from method symbols to their topmost block operations to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the operations, semanticModel and control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetTopmostOperationBlock(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> for given <paramref name="method"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type or
            whose name ends with 'EventArgs'.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOverrideOrVirtualMethodOf(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Find out if the method overrides from target virtual method of a certain type
            or it is the virtual method itself.
            </summary>
            <param name="methodSymbol">The method</param>
            <param name="typeSymbol">The type has virtual method</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsArgumentNullCheckMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if this is a bool returning static method whose name starts with "IsNull"
            with a single parameter whose type is not a value type.
            For example, "static bool string.IsNullOrEmpty()"
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsAutoPropertyAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check if a method is an auto-property accessor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTopLevelStatementsEntryPointMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check if the given <paramref name="methodSymbol"/> is an implicitly generated method for top level statements.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.DerivesFromOrImplementsAnyConstructionOf(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether <paramref name="type"/> derives from, or implements
            any generic construction of, the type defined by <paramref name="parentType"/>.
            </summary>
            <remarks>
            This method only works when <paramref name="parentType"/> is a definition,
            not a constructed type.
            </remarks>
            <example>
            <para>
            If <paramref name="parentType"/> is the class <see cref="T:System.Collections.Generic.Stack`1"/>, then this
            method will return <see langword="true"/> when called on <c>Stack&gt;int></c>
            or any type derived it, because <c>Stack&gt;int></c> is constructed from
            <see cref="T:System.Collections.Generic.Stack`1"/>.
            </para>
            <para>
            Similarly, if <paramref name="parentType"/> is the interface <see cref="T:System.Collections.Generic.IList`1"/>,
            then this method will return <see langword="true"/> for <c>List&gt;int></c>
            or any other class that extends <see cref="T:System.Collections.Generic.IList`1"/> or an class that implements it,
            because <c>IList&gt;int></c> is constructed from <see cref="T:System.Collections.Generic.IList`1"/>.
            </para>
            </example>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.ImplementsEqualityOperators(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified type implements both the
            equality and inequality operators.
            </summary>
            <param name="symbol">
            A symbols specifying the type to examine.
            </param>
            <returns>
            true if the type specified by <paramref name="symbol"/> implements both the
            equality and inequality operators, otherwise false.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsStaticHolderType(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol is a static
            holder type.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> is a static holder type;
            otherwise <see langword="false"/>.
            </returns>
            <remarks>
            A symbol is a static holder type if it is a class with at least one
            "qualifying member" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>) and no
            "disqualifying members" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the specified symbol qualifies as a
            member of a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="member"/> qualifies as a member of
            a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the presence of the specified symbol
            disqualifies a class from being considered a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if the presence of <paramref name="member"/> disqualifies the
            current type as a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsTopLevelStatementsEntryPointType(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Check if the given <paramref name="typeSymbol"/> is an implicitly generated type for top level statements.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetReceiverType(Microsoft.CodeAnalysis.Operations.IInvocationOperation,Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the receiver type for an invocation expression (i.e. type of 'A' in invocation 'A.B()')
            If the invocation actually involves a conversion from A to some other type, say 'C', on which B is invoked,
            then this method returns type A if <paramref name="beforeConversion"/> is true, and C if false.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WithoutFullyImplicitOperations(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation})">
            <summary>
            Filters out operations that are implicit and have no explicit descendant with a constant value or a non-null type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostExplicitDescendants(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets explicit descendants or self of the given <paramref name="operation"/> that have no explicit ancestor in
            the operation tree rooted at <paramref name="operation"/>.
            </summary>
            <param name="operation">Operation</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsOperationNoneRoot(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            True if this operation has no IOperation API support, i.e. <see cref="F:Microsoft.CodeAnalysis.OperationKind.None"/> and
            is the root operation, i.e. <see cref="P:Microsoft.CodeAnalysis.Operation.Parent"/> is null.
            For example, this returns true for attribute operations.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostParentBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> containing the given <paramref name="operation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetFirstParentBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the first <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> in the parent chain of <paramref name="operation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAncestor``1(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.OperationKind,System.Func{``0,System.Boolean})">
            <summary>
            Gets the first ancestor of this operation with:
             1. Specified OperationKind
             2. If <paramref name="predicate"/> is non-null, it succeeds for the ancestor.
            Returns null if there is no such ancestor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAncestor(Microsoft.CodeAnalysis.IOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.OperationKind},System.Func{Microsoft.CodeAnalysis.IOperation,System.Boolean})">
            <summary>
            Gets the first ancestor of this operation with:
             1. Any OperationKind from the specified <paramref name="ancestorKinds"/>.
             2. If <paramref name="predicate"/> is non-null, it succeeds for the ancestor.
            Returns null if there is no such ancestor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetInstance(Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation,System.Boolean)">
            <summary>
            Gets the operation for the object being created that is being referenced by <paramref name="operation"/>.
            If the operation is referencing an implicit or an explicit this/base/Me/MyBase/MyClass instance, then we return "null".
            </summary>
            <param name="operation"></param>
            <param name="isInsideAnonymousObjectInitializer">Flag to indicate if the operation is a descendant of an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation"/>.</param>
            <remarks>
            PERF: Note that the parameter <paramref name="isInsideAnonymousObjectInitializer"/> is to improve performance by avoiding walking the entire IOperation parent for non-initializer cases.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsComparisonOperator(Microsoft.CodeAnalysis.Operations.IBinaryOperation)">
            <summary>
            Indicates if the given <paramref name="binaryOperation"/> is a predicate operation used in a condition.
            </summary>
            <param name="binaryOperation"></param>
            <returns></returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsAdditionOrSubstractionOperation(Microsoft.CodeAnalysis.Operations.IBinaryOperation,System.Char@)">
            <summary>
            Indicates if the given <paramref name="binaryOperation"/> is an addition or substaction operation.
            </summary>
            <param name="binaryOperation"></param>
            <returns>true if the operation is addition or substruction</returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache">
            <summary>
            PERF: Cache from operation roots to their corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetCaptures(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Gets the symbols captured from the enclosing function(s) by the given lambda or local function.
            </summary>
            <param name="operation">Operation representing the lambda or local function.</param>
            <param name="lambdaOrLocalFunction">Method symbol for the lambda or local function.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.TryGetParentTupleOperation(Microsoft.CodeAnalysis.Operations.ITupleOperation,Microsoft.CodeAnalysis.Operations.ITupleOperation@,Microsoft.CodeAnalysis.IOperation@)">
            <summary>
            If the given <paramref name="tupleOperation"/> is a nested tuple,
            gets the parenting tuple operation and the tuple element of that parenting tuple
            which contains the given tupleOperation as a descendant operation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownParentheses(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consecutive parenthesized operations until an operand is reached that isn't a parenthesized operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non parenthesized operation or the starting operation if it wasn't a parenthesized operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consecutive conversion operations until an operand is reached that isn't a conversion operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non conversion operation or the starting operation if it wasn't a conversion operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation,System.Func{Microsoft.CodeAnalysis.Operations.IConversionOperation,System.Boolean})">
            <summary>
            Walks down consecutive conversion operations that satisfy <paramref name="predicate"/> until an operand is reached that
            either isn't a conversion or doesn't satisfy <paramref name="predicate"/>.
            </summary>
            <param name="operation">The starting operation.</param>
            <param name="predicate">A predicate to filter conversion operations.</param>
            <returns>The first operation that either isn't a conversion or doesn't satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.HasArgument``1(Microsoft.CodeAnalysis.Operations.IInvocationOperation,``0@)">
            <summary>
            Determines if the one of the invocation's arguments' values is an argument of the specified type, and if so, find
            the first one.
            </summary>
            <param name="invocationOperation">Invocation operation whose arguments to look through.</param>
            <param name="firstFoundArgument">First found IArgumentOperation.Value of the specified type, order by the method's
            signature's parameters (as opposed to how arguments are specified when invoked).</param>
            <returns>True if one is found, false otherwise.</returns>
            <remarks>
            IInvocationOperation.Arguments are ordered by how they are specified, which may differ from the order in the method
            signature if the caller specifies arguments by name. This will find the first typeof operation ordered by the
            method signature's parameters.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetArgumentsInParameterOrder(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Operations.IArgumentOperation})">
            <summary>
            Useful when named arguments used for a method call and you need them in the original parameter order.
            </summary>
            <param name="arguments">Arguments of the method</param>
            <returns>Returns the arguments in parameter order</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetValueUsageInfo(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the <see cref="T:Analyzer.Utilities.ValueUsageInfo"/> for the given operation.
            This extension can be removed once https://github.com/dotnet/roslyn/issues/25057 is implemented.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsAnyCompoundAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns true if the given operation is a regular compound assignment,
            i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/> such as <code>a += b</code>,
            or a special null coalescing compound assignment, i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>
            such as <code>a ??= b</code>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsBackingFieldForProperty(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IPropertySymbol@)">
            <summary>
            Determines if the given symbol is a backing field for a property.
            </summary>
            <param name="symbol">This symbol to check.</param>
            <param name="propertySymbol">The property that this field symbol is backing.</param>
            <returns>True if the given symbol is a backing field for a property, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsExternallyVisible(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if the symbol is externally visible outside this assembly.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.FormatMemberName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Format member names in a way consistent with FxCop's display format.
            </summary>
            <param name="member"></param>
            <returns>
            A string representing the name of the member in a format consistent with FxCop.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ContainsParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Check whether given parameters contains any parameter with given type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParametersOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Get parameters which type is the given type
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParametersOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the parameters whose type is equal to the given special type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasOverloadWithParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Check whether given overloads has any overload whose parameters has the given type as its parameter type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParameterIndices(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},System.Threading.CancellationToken)">
            <summary>
            Convert given parameters to the indices to the given method's parameter list.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether parameter count and parameter types of the given methods are same.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParameterTypesAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Check whether parameter types of the given methods are same for given parameter indices.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ReturnTypeAndParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether return type, parameters count and parameter types are same for the given methods.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsFromMscorlib(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Check whether given symbol is from mscorlib
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetMatchingOverload(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},System.Int32,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Get overload from the given overloads that matches given method signature + given parameter
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly or explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyImplicitInterfaceMember``1(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyImplicitInterfaceMember``1(Microsoft.CodeAnalysis.ISymbol,``0@)">
            <summary>
            Checks if a given symbol implements an interface member implicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsOverrideOrImplementationOfInterfaceMember(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member or overrides an implementation of an interface member.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetOverriddenMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the symbol overridden by the given <paramref name="symbol"/>.
            </summary>
            <remarks>Requires that <see cref="P:Microsoft.CodeAnalysis.ISymbol.IsOverride"/> is true for the given <paramref name="symbol"/>.</remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyExplicitInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasAttribute(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
            <remarks>
            If <paramref name="symbol"/> is a type, this method does not find attributes
            on its base types.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasDerivedTypeAttribute(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified or inherited symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasDerivedMethodAttribute(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified or inherited method symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasAttributes(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol[])">
            <summary>
            Determines if the given symbol has the specified attributes.
            </summary>
            <param name="symbol">Symbol to examine.</param>
            <param name="attributes">Type symbols of the attributes to check for.</param>
            <returns>Boolean array, same size and order as <paramref name="attributes"/>, indicating that the corresponding
            attribute is present.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetAttributes(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets enumeration of attributes that are of the specified type.
            </summary>
            <param name="symbol">This symbol whose attributes to get.</param>
            <param name="attributeType">Type of attribute to look for.</param>
            <returns>Enumeration of attributes.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsInSource(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Indicates if a symbol has at least one location in source.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer, such as '_', '_1', '_2', etc.
            These symbols can be treated as special discard symbol names.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.IsDisposable(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Indicates if the given <paramref name="type"/> is disposable,
            and thus can be used in a <code>using</code> or <code>await using</code> statement.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.GetApplicableAttributes(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets all attributes directly applied to the type or inherited from a base type.
            </summary>
            <param name="type">The type symbol.</param>
            <param name="attributeUsageAttribute">The compilation symbol for <see cref="T:System.AttributeUsageAttribute"/>.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.HasAnyCollectionCountProperty(Microsoft.CodeAnalysis.ITypeSymbol,Analyzer.Utilities.WellKnownTypeProvider)">
            <summary>
            Checks whether the current type contains one of the following count property:
                - <see cref="P:System.Collections.ICollection.Count"/>
                - <see cref="P:System.Collections.Generic.ICollection`1.Count"/>
                - <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
            </summary>
            <param name="invocationTarget">The type to check</param>
            <param name="wellKnownTypeProvider">An instance of the <see cref="T:Analyzer.Utilities.WellKnownTypeProvider"/> used to access the three described known types.</param>
            <returns><c>true</c> when the type contains one of the supported collection count property; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions">
            <summary>
            Extensions for <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions.IsAtLeastAsVisibleAs(Analyzer.Utilities.Extensions.SymbolVisibility,Analyzer.Utilities.Extensions.SymbolVisibility)">
            <summary>
            Determines whether <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.
            </summary>
            <param name="typeVisibility">The visibility to compare against.</param>
            <param name="comparisonVisibility">The visibility to compare with.</param>
            <returns>True if one can say that <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.</returns>
            <remarks>
            For example, <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/> is at least as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Internal"/>, but <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Private"/> is not as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/>.
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.DisposeMethodKind">
            <summary>
            Describes different kinds of Dispose-like methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.None">
            <summary>
            Not a dispose-like method.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Dispose">
            <summary>
            An override of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeBool">
            <summary>
            A virtual method named Dispose that takes a single Boolean parameter, as
            is used when implementing the standard Dispose pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeAsync">
            <summary>
            A method named DisposeAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeCoreAsync">
            <summary>
            An overridden method named DisposeCoreAsync that takes a single Boolean parameter and returns Task, as
            is used when implementing the standard DisposeAsync pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Close">
            <summary>
            A method named Close on a type that implements <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.CloseAsync">
            <summary>
            A method named CloseAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableAnnotation">
            <summary>
            Represents the nullability of values that can be assigned
            to an expression used as an lvalue.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.None">
            <summary>
            The expression has not been analyzed, or the syntax is
            not an expression (such as a statement).
            </summary>
            <remarks>
            There are a few different reasons the expression could
            have not been analyzed:
                1) The symbol producing the expression comes from
                   a method that has not been annotated, such as
                   invoking a C# 7.3 or earlier method, or a
                   method in this compilation that is in a disabled
                   context.
                2) Nullable is completely disabled in this
                   compilation.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.NotAnnotated">
            <summary>
            The expression is not annotated (does not have a ?).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.Annotated">
            <summary>
            The expression is annotated (does have a ?).
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableContext">
            <summary>
            Represents the state of the nullable analysis at a specific point in a file. Bits one and
            two correspond to whether the nullable feature is enabled. Bits three and four correspond
            to whether the context was inherited from the global context.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Disabled">
            <summary>
            Nullable warnings and annotations are explicitly turned off at this location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsEnabled">
            <summary>
            Nullable warnings are enabled and will be reported at this file location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsEnabled">
            <summary>
            Nullable annotations are enabled and will be shown when APIs defined at
            this location are used in other contexts.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Enabled">
            <summary>
            The nullable feature is fully enabled.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsContextInherited">
            <summary>
            The nullable warning state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsContextInherited">
            <summary>
            The nullable annotation state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.ContextInherited">
             <summary>
             The current state of both warnings and annotations are inherited from
             the project default.
             </summary>
             <remarks>
             This flag is set by default at the start of all files.
            
             The project default can change depending on the file type. Generated
             files have nullable off by default, regardless of the project-level
             default setting.
             </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable warnings are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable annotations are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable warning state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable annotation state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.OperationWrapperHelper.GetWrappedType(System.Type)">
            <summary>
            Gets the type that is wrapped by the given wrapper.
            </summary>
            <param name = "wrapperType">Type of the wrapper for which the wrapped type should be retrieved.</param>
            <returns>The wrapped type, or <see langword="null"/> if there is no info.</returns>
        </member>
        <member name="T:Analyzer.Utilities.MSBuildItemOptionNames">
            <summary>
            MSBuild item names that are required to be threaded as analyzer config options.
            The analyzer config option will have the following key/value:
            - Key: Item name prefixed with an '_' and suffixed with a 'List' to reduce chances of conflicts with any existing project property.
            - Value: Concatenated item metadata values, separated by a ',' character. See https://github.com/dotnet/sdk/issues/12706#issuecomment-668219422 for details.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.OptionKind">
            <summary>
            Kind of option to fetch from <see cref="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.OptionKind.DotnetCodeQuality">
            <summary>
            Option prefixed with <c>dotnet_code_quality.</c>.
            <para>Used for custom analyzer config options for analyzers in this repo.</para>
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.OptionKind.BuildProperty">
            <summary>
            Option prefixed with <c>build_property.</c>.
            <para>Used for options generated for MSBuild properties.</para>
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.MSBuildPropertyOptionNames">
            <summary>
            MSBuild property names that are required to be threaded as analyzer config options.
            </summary>
            <remarks>const fields in this type are automatically discovered and used to generate build_properties entries in the generated .globalconfig</remarks>
        </member>
        <member name="T:Analyzer.Utilities.SyntaxTreeCategorizedAnalyzerConfigOptions">
            <summary>
            Analyzer configuration options for a given syntax tree from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions"/>
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions">
             <summary>
             Analyzer configuration options that are parsed into general and specific configuration options.
            
             <para><strong>.editorconfig</strong> format:</para>
             <list type="number">
             <item><description>General configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             </list>
             </description></item>
             <item><description>Specific configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.<em>RuleId</em>.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             <item><description><c>dotnet_code_quality.<em>RuleCategory</em>.<em>OptionName</em> = <em>OptionValue</em></c></description></item>
             </list>
             </description></item>
             </list>
            
             <para><strong>.editorconfig</strong> examples to configure API surface analyzed by analyzers:</para>
             <list type="number">
             <item><description>General configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.api_surface = all</c></description></item>
             </list>
             </description></item>
             <item><description>Specific configuration option:
             <list type="number">
             <item><description><c>dotnet_code_quality.CA1040.api_surface = public, internal</c></description></item>
             <item><description><c>dotnet_code_quality.Naming.api_surface = public</c></description></item>
             </list>
             </description></item>
             </list>
            
             <para>See <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> for allowed symbol visibility value combinations.</para>
             </summary>
        </member>
        <member name="T:Analyzer.Utilities.AggregateCategorizedAnalyzerConfigOptions">
             <summary>
             Aggregate analyzer configuration options:
            
             <list type="number">
             <item><description>Per syntax tree options from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider"/>.</description></item>
             <item><description>Options from an <strong>.editorconfig</strong> file passed in as an additional file (back compat).</description></item>
             </list>
            
             <inheritdoc cref="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions"/>
             </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardNamesBySymbolKind">
            <summary>
            Dictionary holding per symbol kind the wildcard entry with its suffix.
            The implementation only supports the following SymbolKind: Namespace, Type, Event, Field, Method, Property and ErrorType (as a way to hold the non-fully qualified types).
            </summary>
            <example>
            ErrorType ->
                Symbol* -> "some value"
            Namespace ->
                Analyzer.Utilities -> ""
            Type ->
                Analyzer.Utilities.SymbolNamesWithValueOption -> ""
            Event ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyEvent -> ""
            Field ->
                Analyzer.Utilities.SymbolNamesWithValueOption.myField -> ""
            Method ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyMethod() -> ""
            Property ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyProperty -> ""
            </example>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardMatchResult">
            <summary>
            Cache for the wildcard matching algorithm. The current implementation can be slow so we want to make sure that once a match is performed we save its result.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolNamesWithValueOption`1.TryGetValue(Microsoft.CodeAnalysis.ISymbol,`0@)">
            <summary>
            Gets the value associated with the specified symbol in the option specification.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolNamesWithValueOption`1.NameParts">
            <summary>
            Represents the two parts of a symbol name option when the symbol name is tighted to some specific value.
            This allows to link a value to a symbol while following the symbol's documentation ID format.
            </summary>
            <example>
            On the rule CA1710, we allow user specific suffix to be registered for symbol names using the following format:
            MyClass->Suffix or T:MyNamespace.MyClass->Suffix or N:MyNamespace->Suffix.
            </example>
        </member>
        <member name="T:Analyzer.Utilities.SymbolModifiers">
            <summary>
            Describes a group of modifiers for symbol declaration.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Unit">
            <summary>
            Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
            </summary>
            <remarks>
            This class is a duplicate from "https://github.com/dotnet/reactive/blob/main/Rx.NET/Source/src/System.Reactive/Unit.cs
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the specified <see cref="T:Analyzer.Utilities.Unit"/> value is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="other">An object to compare to the current <see cref="T:Analyzer.Utilities.Unit"/> value.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>.
            </summary>
            <param name="obj">The System.Object to compare with the current <see cref="T:Analyzer.Utilities.Unit"/>.</param>
            <returns><c>true</c> if the specified System.Object is a <see cref="T:Analyzer.Utilities.Unit"/> value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>A hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.ToString">
            <summary>
            Returns a string representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>String representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Equality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Inequality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are not equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.</returns>
        </member>
        <member name="P:Analyzer.Utilities.Unit.Default">
            <summary>
            Gets the single <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Read">
            <summary>
            Represents a value read.
            For example, reading the value of a local/field/parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Write">
            <summary>
            Represents a value write.
            For example, assigning a value to a local/field/parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Reference">
            <summary>
            Represents a reference being taken for the symbol.
            For example, passing an argument to an "in", "ref" or "out" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.Name">
            <summary>
            Represents a name-only reference that neither reads nor writes the underlying value.
            For example, 'nameof(x)' or reference to a symbol 'x' in a documentation comment
            does not read or write the underlying value stored in 'x'.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadWrite">
            <summary>
            Represents a value read and/or write.
            For example, an increment or compound assignment operation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "in" or "ref readonly" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.WritableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "out" parameter.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.ValueUsageInfo.ReadableWritableReference">
            <summary>
            Represents a value read or write.
            For example, passing an argument to a "ref" parameter.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.EditorConfigOptionNames">
            <summary>
            Option names to configure analyzer execution through an .editorconfig file.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ApiSurface">
            <summary>
            Option to configure analyzed API surface.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.RequiredModifiers">
            <summary>
            Option to configure required modifiers for analyzed APIs.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolModifiers"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAsyncVoidMethods">
            <summary>
            Boolean option to exclude analysis of async void methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnablePlatformAnalyzerOnPreNet5Target">
            <summary>
            Boolean option to enable platform compatibility analyzer for TFMs with lower version than net5.0 (https://learn.microsoft.com/visualstudio/code-quality/ca1416).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.OutputKind">
            <summary>
            Option to configure analyzed output kinds, i.e. <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> of the compilation.
            Allowed option values: One or more fields of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeSingleLetterTypeParameters">
            <summary>
            Boolean option to configure if single letter type parameter names are not flagged for CA1715 (https://learn.microsoft.com/visualstudio/code-quality/ca1715).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.SufficientIterationCountForWeakKDFAlgorithm">
            <summary>
            Integral option to configure sufficient IterationCount when using weak KDF algorithm.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeExtensionMethodThisParameter">
            <summary>
            Boolean option to exclude analysis of 'this' parameter for extension methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.NullCheckValidationMethods">
            <summary>
            String option to configure names of null check validation methods (separated by '|') that validate arguments passed to the method are non-null for CA1062 (https://learn.microsoft.com/visualstudio/code-quality/ca1062).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalStringFormattingMethods">
            <summary>
            String option to configure names of additional string formatting methods (separated by '|') for CA2241 (https://learn.microsoft.com/visualstudio/code-quality/ca2241).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.TryDetermineAdditionalStringFormattingMethodsAutomatically">
            <summary>
            Boolean option to enable heuristically detecting of additional string formatting methods for CA2241 (https://learn.microsoft.com/visualstudio/code-quality/ca2241).
            A method is considered a string formatting method if it has a '<see cref="T:System.String"/> <c>format</c>' parameter followed by a <see langword="params"/> <see cref="T:System.Object"/>[]' parameter.
            The default value of this is <c>false</c>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are excluded for analysis.
            Configurable rules: CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedTypeNamesWithDerivedTypes">
            <summary>
            String option to configure names of types (separated by '|'), so that the type and all its derived types are excluded for analysis.
            Configurable rules: CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisallowedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are disallowed in analysis.
            Configurable rules: CA1031 (https://learn.microsoft.com/visualstudio/code-quality/ca1031).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UnsafeDllImportSearchPathBits">
            <summary>
            Enumeration option to configure unsafe DllImportSearchPath bits when using DefaultDllImportSearchPaths attribute.
            Do not use the OR operator to represent the bitwise combination of its member values, use the integral value directly.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAspnetCoreMvcControllerBase">
            <summary>
            Boolean option to configure whether to exclude aspnet core mvc ControllerBase when considering CSRF.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnumValuesPrefixTrigger">
            <summary>
            String option to configure how many enum values should be prefixed by the enum type name to trigger the rule.
            Configurable rules: CA1712 (https://learn.microsoft.com/visualstudio/code-quality/ca1712)
            Allowed method name formats:
              1. Any of the enum values starts with the enum type name
              2. All of the enum values starts with the enum type name
              3. Default FxCop heuristic (75% of enum values)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredSuffixes">
            <summary>
            String option to configure names of types (separated by '|'), with their suffixes (separated by '->').
            Configurable rules: CA1710 (https://learn.microsoft.com/visualstudio/code-quality/ca1710).
            Allowed type name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeIndirectBaseTypes">
            <summary>
            Boolean option to prevent analyzing indirect base types (walking more than one level up) when suggesting suffixes.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredGenericInterfaces">
            <summary>
            String option to configure names of interfaces (separated by '|'), with their required generic interfaces (separated by '->').
            Configurable rules: CA1010 (https://learn.microsoft.com/visualstudio/code-quality/ca1010)
            Allowed interface formats:
              1. Interface name only(includes all interfaces with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalInheritanceExcludedSymbolNames">
            <summary>
            Names of types or namespaces (separated by '|'), such that the type or type's namespace doesn't count in the inheritance hierarchy tree.
            Configurable rules: CA1501 (https://learn.microsoft.com/visualstudio/code-quality/ca1501)
            Allowed name formats:
              1. Type or namespace name (includes all types with the name, regardless of the containing type or namespace and all types whose namespace contains the name)
              2. Type or namespace name ending with a wildcard symbol (includes all types whose name starts with the given name, regardless of the containing type or namespace
                 and all types whose namespace contains the name)
              3. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format with an optional "T:" prefix for types or "N:" prefix for namespaces. (includes all types with the exact type match or the exact containing namespace match)
              4. Fully qualified type or namespace name with an optional "T:" prefix for type or "N:" prefix for namespace and ending with the wildcard symbol (includes all types whose fully qualified name starts with the given suffix)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AnalyzedSymbolKinds">
            <summary>
            Option to configure analyzed symbol kinds, i.e. <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>.
            Allowed option values: One or more fields of <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UseNamingHeuristic">
            <summary>
            Boolean option to configure if the naming heuristic should be used for CA1303 (https://learn.microsoft.com/visualstudio/code-quality/ca1303).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalUseResultsMethods">
            <summary>
            String option to configure names of additional methods (separated by '|') for CA1806 (https://learn.microsoft.com/visualstudio/code-quality/ca1806).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AllowedSuffixes">
            <summary>
            String option to configure allowed suffixed (separated by '|').
            Configurable rule: CA1711 (https://learn.microsoft.com/visualstudio/code-quality/ca1711).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeStructs">
            <summary>
            Boolean option to configure whether to exclude structs when considering public fields.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeOrDefaultMethods">
            <summary>
            Boolean option to configure whether to exclude 'FirstOrDefault' and 'LastOrDefault' methods for
            CA1826 (Do not use Enumerable methods on indexable collections. Instead use the collection directly).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnumerationMethods">
            <summary>
            String option to configure names of method symbols (separated by '|') that marks all of the parameters with IEnumerable type
            would be enumerated.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.LinqChainMethods">
            <summary>
            String option to configure names of method symbols (separated by '|') that accepting parameter with IEnumerable type and return a new IEnumerable type, like 'Select' and 'Where'.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AssumeMethodEnumeratesParameters">
            <summary>
            Boolean option to configure the assumption that IEnumerable type parameters would be enumerated by method invocation or not.
            It does not affect linq_chain_methods.
            Configurable rule: CA1851 (https://learn.microsoft.com/visualstudio/code-quality/ca1851).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalEnumNoneNames">
            <summary>
            String option to configure names of additional "None" enum case (separated by '|') for CA1008.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolVisibilityGroup">
            <summary>
            Describes a group of effective <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/> for symbols.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given source symbol has required visibility based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilities.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given symbol has required visibility based on options in context of the given containing symbol:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilities.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.AnalyzerOptionsExtensions.MatchesConfiguredModifiers(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,Analyzer.Utilities.SymbolModifiers)">
            <summary>
            Returns true if the given symbol has required symbol modifiers based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolModifiers"/> in editor config options and
                 given symbol has all the required modifiers.
              2. Otherwise, if user has not configured modifiers.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.SmallDictionary`2">
             <summary>
             Copied from https://github.com/dotnet/roslyn/blob/main/src/Compilers/Core/Portable/Collections/SmallDictionary.cs
             Dictionary designed to hold small number of items.
             Compared to the regular Dictionary, average overhead per-item is roughly the same, but
             unlike regular dictionary, this one is based on an AVL tree and as such does not require
             rehashing when items are added.
             It does require rebalancing, but that is allocation-free.
            
             Major caveats:
              1) There is no Remove method. (can be added, but we do not seem to use Remove that much)
              2) foreach [keys|values|pairs] may allocate a small array.
              3) Performance is no longer O(1). At a certain count it becomes slower than regular Dictionary.
                 In comparison to regular Dictionary on my machine:
                    On trivial number of elements (5 or so) it is more than 2x faster.
                    The break even count is about 120 elements for read and 55 for write operations (with unknown initial size).
                    At UShort.MaxValue elements, this dictionary is 6x slower to read and 4x slower to write
            
             Generally, this dictionary is a win if number of elements is small, not known beforehand or both.
            
             If the size of the dictionary is known at creation and it is likely to contain more than 10 elements,
             then regular Dictionary is a better choice.
             </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolDisplayStringCache">
            <summary>
            Cache ISymbol.ToDisplayName() results, to avoid performance concerns.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.s_byCompilationCache">
            <summary>
            Caches by compilation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.NullSymbolDisplayFormat">
            <summary>
            ConcurrentDictionary key for a null SymbolDisplayFormat.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolDisplayStringCache.SymbolToDisplayNames">
            <summary>
            Mapping of a symbol to its ToDisplayString().
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.#ctor(Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Privately constructs.
            </summary>
            <param name="format">SymbolDisplayFormat to use, or null for the default.</param>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.GetOrCreate(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Gets the symbol display string cache for the compilation.
            </summary>
            <param name="compilation">Compilation that this cache is for.</param>
            <param name="format">A singleton SymbolDisplayFormat to use, or null for the default.</param>
            <returns>A SymbolDisplayStringCache.</returns>
        </member>
        <member name="M:Analyzer.Utilities.SymbolDisplayStringCache.GetDisplayString(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the symbol's display string.
            </summary>
            <param name="symbol">Symbol to get the display string.</param>
            <returns>The symbol's display string.</returns>
        </member>
        <member name="T:Analyzer.Utilities.SymbolByDisplayStringComparer">
            <summary>
            <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>s sorted by display strings.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.#ctor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Constructs.
            </summary>
            <param name="compilation">The compilation containing the types to be compared.</param>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.#ctor(Analyzer.Utilities.SymbolDisplayStringCache)">
            <summary>
            Constructs.
            </summary>
            <param name="symbolDisplayStringCache">The cache display strings to use.</param>
        </member>
        <member name="P:Analyzer.Utilities.SymbolByDisplayStringComparer.SymbolDisplayStringCache">
            <summary>
            Cache of symbol display strings.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolByDisplayStringComparer.Compare(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Compares two type symbols by their display strings.
            </summary>
            <param name="x">First type symbol to compare.</param>
            <param name="y">Second type symbol to compare.</param>
            <returns>Less than 0 if <paramref name="x"/> is before <paramref name="y"/>, 0 if equal, greater than 0 if
            <paramref name="x"/> is after <paramref name="y"/>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.UnusedValue">
            <summary>
            A placeholder value type for <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> used as a set.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WellKnownTypeProvider">
            <summary>
            Provides and caches well known types in a compilation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._referencedAssemblies">
            <summary>
            All the referenced assembly symbols.
            </summary>
            <remarks>
            Seems to be less memory intensive than:
            foreach (Compilation.Assembly.Modules)
                foreach (Module.ReferencedAssemblySymbols)
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._fullNameToTypeMap">
            <summary>
            Mapping of full name to <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._fullTypeNameToNamespaceNames">
             <summary>
             Static cache of full type names (with namespaces) to namespace name parts,
             so we can query <see cref="P:Microsoft.CodeAnalysis.IAssemblySymbol.NamespaceNames"/>.
             </summary>
             <remarks>
             Example: "System.Collections.Generic.List`1" => [ "System", "Collections", "Generic" ]
            
             https://github.com/dotnet/roslyn/blob/9e786147b8cb884af454db081bb747a5bd36a086/src/Compilers/CSharp/Portable/Symbols/AssemblySymbol.cs#L455
             suggests the TypeNames collection can be checked to avoid expensive operations. But realizing TypeNames seems to be
             as memory intensive as unnecessary calls GetTypeByMetadataName() in some cases. So we'll go with namespace names.
             </remarks>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.TryGetOrCreateTypeByMetadataName(System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Attempts to get the type by the full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <param name="namedTypeSymbol">Named type symbol, if any.</param>
            <returns>True if found in the compilation, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.GetOrCreateTypeByMetadataName(System.String)">
            <summary>
            Gets a type by its full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.IsTaskOfType(Microsoft.CodeAnalysis.ITypeSymbol,System.Func{Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean})">
            <summary>
            Determines if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its type
            argument satisfying <paramref name="typeArgumentPredicate"/>.
            </summary>
            <param name="typeSymbol">Type potentially representing a <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="typeArgumentPredicate">Predicate to check the <paramref name="typeSymbol"/>'s type argument.</param>
            <returns>True if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its
            type argument satisfying <paramref name="typeArgumentPredicate"/>, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCache`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WordParser">
            <summary>
                Provides <see langword="static"/> methods for parsing words from text.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text and options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text, options and prefix.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Char,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.NextWord">
            <summary>
                Returns the next word in the text.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.PeekWord">
            <summary>
                Returns the next word in the text without consuming it.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="T:Analyzer.Utilities.WordParserOptions">
            <summary>
              Defines the word parsing and delimiting options for use with <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.None">
            <summary>
              Indicates the default options for word parsing.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.IgnoreMnemonicsIndicators">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should ignore the mnemonic indicator characters (&amp;) embedded within words.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.SplitCompoundWords">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should split compound words.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.DocumentBasedFixAllProvider">
            <summary>
            Provides a base class to write a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that fixes documents independently.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.DocumentBasedFixAllProvider.FixAllInDocumentAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Fixes all occurrences of a diagnostic in a specific document.
            </summary>
            <param name="fixAllContext">The context for the Fix All operation.</param>
            <param name="document">The document to fix.</param>
            <param name="diagnostics">The diagnostics to fix in the document.</param>
            <returns>
            <para>The new <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the root of the fixed document.</para>
            <para>-or-</para>
            <para><see langword="null"/>, if no changes were made to the document.</para>
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.FixAllContextHelper.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets all <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instances within a specific <see cref="T:Microsoft.CodeAnalysis.Project"/> which are relevant to a
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
            <param name="fixAllContext">The context for the Fix All operation.</param>
            <param name="project">The project.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> representing the asynchronous operation. When the task completes
            successfully, the <see cref="P:System.Threading.Tasks.Task`1.Result"/> will contain the requested diagnostics.</returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorEqualityDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator equality overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.TypeExpressionForStaticMemberAccess(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a reference to a named type suitable for use in accessing a static member of the type.
            </summary>
            <param name="generator">The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the type reference.</param>
            <param name="typeSymbol">The named type to reference.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the type reference expression.</returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorInequalityDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator inequality overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorLessThanDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator less than overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorLessThanOrEqualDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator less than or equal overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorGreaterThanDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator greater than overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorGreaterThanOrEqualDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator greater than or equal overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultEqualsOverrideDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an override of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="compilation">The compilation</param>
            <param name="containingType">
            A symbol specifying the type in which the declaration is to be created.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultGetHashCodeOverrideDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Creates a default declaration for an override of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="compilation">The compilation</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultMethodBody(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Creates a default set of statements to place within a generated method body.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the statements.
            </param>
            <param name="compilation">The compilation</param>
            <returns>
            An sequence containing a single statement that throws <see cref="T:System.NotImplementedException"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxNodeExtensions.WithAddImportsAnnotation(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Annotates a syntax node representing a type so that any missing imports get automatically added. Does not work in any other kinds of nodes.
            </summary>
            <param name="syntaxNode">The type node to annotate.</param>
            <returns>The annotated type node.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData">
            <summary>
            Code analysis metrics data.
            See https://learn.microsoft.com/visualstudio/code-quality/code-metrics-values for more details
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol">
            <summary>
            Symbol corresponding to the metric data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.MaintainabilityIndex">
            <summary>
            Indicates an index value between 0 and 100 that represents the relative ease of maintaining the code.
            A high value means better maintainability.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CoupledNamedTypes">
            <summary>
            Indicates the coupling to unique named types through parameters, local variables, return types, method calls,
            generic or template instantiations, base classes, interface implementations, fields defined on external types, and attribute decoration.
            Good software design dictates that types and methods should have high cohesion and low coupling.
            High coupling indicates a design that is difficult to reuse and maintain because of its many interdependencies on other types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.SourceLines">
            <summary>
            Indicates the exact number of lines in source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ExecutableLines">
            <summary>
            Indicates the approximate number of executable statements/lines in code.
            The count is based on the executable <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s in code and is therefore not the exact number of lines in the source code file.
            A high count might indicate that a type or method is trying to do too much work and should be split up.
            It might also indicate that the type or method might be hard to maintain.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CyclomaticComplexity">
            <summary>
            Measures the structural complexity of the code.
            It is created by calculating the number of different code paths in the flow of the program.
            A program that has complex control flow requires more tests to achieve good code coverage and is less maintainable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.DepthOfInheritance">
            <summary>
            Indicates the number of different classes that inherit from one another, all the way back to the base class.
            Depth of Inheritance is similar to class coupling in that a change in a base class can affect any of its inherited classes.
            The higher this number, the deeper the inheritance and the higher the potential for base class modifications to result in a breaking change.
            For Depth of Inheritance, a low value is good and a high value is bad.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Children">
            <summary>
            Array of code metrics data for symbolic children of <see cref="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ToString">
            <summary>
            Computes string representation of metrics data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics">
            <summary>
            Calculates computational complexity metrics based on the number
            of operators and operands found in the code.
            </summary>
            <remarks>This metric is based off of the Halstead metric.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperators">
            <summary>The number of unique operators found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperands">
            <summary>The number of unique operands found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperators">
            <summary>The total number of operator usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperands">
            <summary>The total number of operand usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.ExecutableLines">
            <summary>
            Count of executable lines of code, i.e. basically IOperations parented by IBlockOperation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.EffectiveLinesOfCode">
            <summary>
            Count of effective lines of code for computation of maintainability index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GenerateEditorconfig(System.String,System.String)">
            <summary>
            Converts a ruleset file at the given <paramref name="rulesetFilePath"/>, including all its ruleset includes,
            into an .editorconfig file at the given <paramref name="editorconfigFilePath"/>
            </summary>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset files.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GetEditorconfig(System.String)">
            <summary>
            Gets an .editorconfig representation for a ruleset file at the given <paramref name="rulesetFilePath"/>,
            including all its ruleset includes.
            </summary>
            <returns>Text for equivalent .editorconfig</returns>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset file.</exception>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
    </members>
</doc>
